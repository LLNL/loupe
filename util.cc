//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2018, Lawrence Livermore National Security, LLC.
// Produced at the Lawrence Livermore National Laboratory.
//
// Written by Emilio Castillo <ecastill@bsc.es>.
// LLNL-CODE-745958. All rights reserved.
//
// This file is part of Loupe. For details, see:
// https://github.com/LLNL/loupe
// Please also read the LICENSE file for the MIT License notice.
//////////////////////////////////////////////////////////////////////////////

#define UNW_LOCAL_ONLY
#include <cxxabi.h>
#include <libunwind.h>
#include <stdio.h>
#include <iomanip>
#include <iostream>
#include <fstream>
#include <sstream>
#include "util.hh"

std::map<uint64_t, std::string> g_symbols;

// Call this function to get a backtrace.
void backtrace(uint64_t *pc_val) {

    char sym[256];
    char aux[256];

    unw_cursor_t cursor;
    unw_context_t context;

    // Initialize cursor to current frame for local unwinding.
    unw_getcontext(&context);
    unw_init_local(&cursor, &context);

    // Unwind frames until we get to the caller
    unw_step(&cursor);
    unw_step(&cursor);
    unw_step(&cursor);

    //while (unw_step(&cursor) > 0) {
    unw_word_t offset, pc;
    unw_get_reg(&cursor, UNW_REG_IP, &pc);
    *pc_val = pc;
    if(g_symbols.find(pc)==g_symbols.end()){
        if (unw_get_proc_name(&cursor, aux, sizeof(aux), &offset) == 0) {
            int status; 
            char* demangled = abi::__cxa_demangle(aux, nullptr, nullptr, &status);
            if(demangled){
                sprintf(sym,"(%s+0x%lx)", demangled, offset);
                std::free(demangled);
            } else {
                sprintf(sym,"(%s+0x%lx)", aux, offset);
            }
        } else {
            sprintf(sym,"(UNKNOWN+0x%lx)", offset);
        }
        g_symbols[*pc_val] = sym;
    }
}


// Creates a dict file for the PC and the calls name
void dump_symbols(std::string* callnames, const std::string& name){
    //Prepare all the data in the symbols
    //We will need to receive the symbols from other ranks too
    //ALL GATHER
    std::ostringstream filename;
    filename << name << ".sym";
    std::ofstream myfile (filename.str());
    for(auto it=g_symbols.begin();it!=g_symbols.end();it++){
        myfile << it->first << "\t"<< it->second <<std::endl; 
    }
    //TODO only output the ids of the calls we did
    //356 is the number of mpi calls generated by wrap
    for(int i=0;i<356;i++){
        myfile << i << "\t" << callnames[i] <<std::endl;
    }
    myfile.close();
}
